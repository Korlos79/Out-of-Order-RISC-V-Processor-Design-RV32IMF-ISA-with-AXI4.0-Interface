module scoreboard (
    input wire clk, rst_n,

    // --- Interface với Dispatcher (Issue Stage) ---
    input  wire       issue_valid,      // Có lệnh muốn thực thi
    input  wire [4:0] issue_rd,         // Thanh ghi đích
    input  wire [2:0] issue_fu_id,      // Loại Unit sẽ thực thi (0:ALU, 1:MUL, 2:LSU...)
    output reg        can_issue,        // Cho phép Issue không? (Check WAW)

    // --- Interface với CDB (Writeback Stage) ---
    input  wire       cdb_valid,
    input  wire [4:0] cdb_rd,           // Thanh ghi vừa được ghi xong
    input  wire [2:0] cdb_source_fu,    // Ai vừa ghi xong?

    // --- Interface truy vấn (Read Operands) ---
    input  wire [4:0] rs1,
    output reg        rs1_ready,        // 1: Có dữ liệu, 0: Đang chờ
    output reg  [2:0] rs1_tag           // Nếu chờ thì chờ ai?
    // (Tương tự cho rs2)
);

    // Bảng trạng thái: Bit Busy và Tag (ID của FU)
    reg [32:0] reg_busy;       // Bit 0 không dùng (x0 luôn = 0)
    reg [2:0]  reg_tag [31:0]; // Lưu ID của FU đang chiếm giữ thanh ghi

    // 1. Logic Issue (Cấp phát)
    always @(*) begin
        // WAW Check: Nếu thanh ghi đích đang bận -> Stall (Không cho Issue)
        // (Trong Tomasulo xịn dùng Rename Register để bỏ qua bước này, nhưng Scoreboard đơn giản thì cần)
        if (reg_busy[issue_rd] && issue_rd != 0) 
            can_issue = 1'b0;
        else 
            can_issue = 1'b1;
    end

    // 2. Logic Cập nhật Bảng (Sequential)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_busy <= 0;
            // Reset tags...
        end else begin
            // ISSUE: Đánh dấu thanh ghi đích là Bận
            if (issue_valid && can_issue && issue_rd != 0) begin
                reg_busy[issue_rd] <= 1'b1;
                reg_tag[issue_rd]  <= issue_fu_id;
            end

            // WRITEBACK: Đánh dấu thanh ghi đích là Rảnh
            // (Chỉ khi kết quả trả về đúng là từ FU đang giữ quyền)
            if (cdb_valid && cdb_rd != 0) begin
                if (reg_tag[cdb_rd] == cdb_source_fu) begin
                    reg_busy[cdb_rd] <= 1'b0;
                end
            end
        end
    end

    // 3. Logic Truy vấn (Combinational)
    always @(*) begin
        if (rs1 == 0) begin
            rs1_ready = 1; rs1_tag = 0;
        end else begin
            rs1_ready = ~reg_busy[rs1]; // Nếu không bận nghĩa là có dữ liệu
            rs1_tag   = reg_tag[rs1];
        end
    end

endmodule